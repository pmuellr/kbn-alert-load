<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>%reportName% - kbn-alert-load report</title>
  <link rel="shortcut icon" href="https://elastic.co/favicon.ico" type="image/x-icon">
  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-lite@4"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-embed@6"></script>
  <!--
  <script src="https://cdn.jsdelivr.net/npm/vega@5/build/vega.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-lite@4/build/vega-lite.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-embed@6/build/vega-embed.js"></script>
  -->
  
  <style>
    td {
      padding-top: 0;
      padding-bottom: 0;
    }
    h3, h4, table {
      margin: 0.5em 0;
    }
    .viz {
      width: 100%;
      padding: 1em 2em;
    }
    .indent {
      margin-left: 2em;
    }
  </style>
</head>

<body>
  <h1>%reportName% - kbn-alert-load report</h1>

  <table width="100%">
    <tr>
      <td valign="top">
        <h3>load test results for Kibana alerting</h3>
        <table>
          <tr><td>suite:</td><td id='var-description'></td></tr>
          <tr><td>date:</td><td>%date%</td></tr>
          <tr><td>zone:</td><td>%zone%</td></tr>
          <tr><td>suite id:</td><td id='var-suite'></td></tr>
        </table>
      </td>
      <td valign="top">
        <h3>common scenario settings</h3>
        <table id='table-shared-settings'></table>
      </td>
    </tr>
  </table>
  
  <!--
  <h3>scenario-specific settings</h3>
  <div class='indent'>
    <div id='table-scenario-settings'></div>
  </div>
  -->

  <div class="viz" id="vis-executions-per-minute"></div>
  <div class="viz" id="vis-execution-failures-per-minute"></div>
  <div class="viz" id="vis-execution-time"></div>
  <div class="viz" id="vis-time-between-alert-executions"></div>
  <div class="viz" id="vis-kb-status"></div>
  <div class="viz" id="vis-es-status"></div>
  <div class="viz" id="vis-kb-tm-stats"></div>
  <div class="viz" id="vis-kb-tm-runtime-stats"></div>
  <div class="viz" id="vis-kb-tm-polling-stats"></div>
  <div class="viz" id="vis-kb-tm-schedule"></div>
  <div class="viz" id="vis-kb-tm-polling-results-stats"></div>

  <p><i>generated by <a href='https://github.com/pmuellr/kbn-alert-load'>kbn-alert-load</a></i></p>
</body>

<script>
  'use strict'
  const { eventLog, kbStatus, KbTaskManager, esStatus, suite, deployments } = getAllData()
  const chartWidth = 200
  const colors = [
    '#00BFB3',
    '#F04E98',
    '#1BA9F5',
    '#0077CC',
  ]

  document.getElementById('var-suite').innerHTML = suite.id
  document.getElementById('var-description').innerHTML = suite.description
  document.getElementById('table-shared-settings').innerHTML = getSharedSettings()
  // document.getElementById('table-scenario-settings').innerHTML = getScenarioSetttings()

  const earliestDate = Date.parse(eventLog[0].date)

  // augment the eventLog
  eventLog.forEach(event => {
    event.dateNumber = Date.parse(event.date)
    event.dateRelative = event.dateNumber - earliestDate
    event.minute = event.dateRelative / 1000 / 60
  })

  // augment the kbStatus
  kbStatus.forEach(status => {
    status.dateNumber = Date.parse(status.metrics.last_updated)
    status.dateRelative = status.dateNumber - earliestDate
    status.minute = status.dateRelative / 1000 / 60
  })

  Object.keys(KbTaskManager)
    .forEach(scenario => {
      const earliestTMDateInScenario = Math.min(
        ...Object.values(KbTaskManager[scenario]).map(stats => Date.parse(stats[0].timestamp))
      )

      // augment the KbTaskManager
      Object.keys(KbTaskManager[scenario]).forEach(tmId => {
        KbTaskManager[scenario][tmId].forEach(stats => {
          const pollInterval = stats.stats.configuration.value.poll_interval
          stats.dateNumber = Date.parse(stats.timestamp)
          stats.dateRelative = stats.dateNumber - earliestTMDateInScenario
          stats.minute = stats.dateRelative / 1000 / 60
        })
      })
    })

  // augment the esStatus
  esStatus.forEach(status => {
    status.dateNumber = Date.parse(status.date)
    status.dateRelative = status.dateNumber - earliestDate
    status.minute = status.dateRelative / 1000 / 60

    status.heapPercent = parseInt(status['heap.percent'], 10)
    status.ramPercent = parseInt(status['ram.percent'], 10)
    status.cpuPercent = parseInt(status.cpu, 10)
  })

  const lastExecutions = new Map()
  eventLog.forEach(event => {
    if (!event.alert) return

    const key = `${event.deployment}-${event.alert}`
    const lastExecution = lastExecutions.get(key)
    if (lastExecution) {
      event.lastInterval = (event.dateNumber - lastExecution) / 1000 / 60
    }
    lastExecutions.set(key, event.dateNumber)
  })

  vegaEmbed('#vis-execution-time', {
    $schema: 'https://vega.github.io/schema/vega-lite/v4.json',
    title: 'execution time',
    width: chartWidth,
    mark: { 
      type: 'point', 
      size: 100,
      strokeWidth: 1,
      opacity: 0.7,
      color: colors[0],
      tooltip: true
    },
    encoding: {
      x: {
        title: 'minutes since start',
        field: 'dateRelative',
        type: 'temporal',
        axis: {
          format: '%-M',
          formatType: 'time',
          tickCount: 'minute',
        }
      },
      y: {
        title: 'execution time (milliseconds)',
        field: 'duration',
        type: 'quantitative',
        scale: { zero: true, type: 'log' },
        axis: { grid: false }
      },
      column: {
        field: 'scenario',
        header: { title: null },
      }
    },
    data: { values: eventLog }
  })

  vegaEmbed('#vis-time-between-alert-executions', {
    $schema: 'https://vega.github.io/schema/vega-lite/v4.json',
    title: 'times between alert executions',
    width: chartWidth,
    mark: { 
      type: 'point', 
      shape: 'square',
      size: 100,
      strokeWidth: 1,
      opacity: 0.4,
      color: colors[1],
      tooltip: true
    },
    encoding: {
      x: {
        title: 'minutes since start',
        field: 'dateRelative',
        type: 'temporal',
        axis: {
          format: '%-M',
          formatType: 'time',
          tickCount: 'minute',
        }
      },
      y: {
        title: 'last execution (minutes)',
        field: 'lastInterval',
        type: 'quantitative',
        scale: { zero: true },
        axis: { grid: false }
      },
      column: {
        field: 'scenario',
        header: { title: null },
      }
    },
    data: { values: eventLog }
  })

  vegaEmbed('#vis-executions-per-minute', {
    $schema: 'https://vega.github.io/schema/vega-lite/v4.json',
    title: 'executions per minute',
    width: chartWidth,
    mark: { 
      type: 'bar', 
      tooltip: true, 
      cornerRadiusEnd: 4,
      color: colors[2],
    },
    encoding: {
      x: {
        bin: { step: 1 },
        field: 'minute',
        type: 'ordinal',
        title: 'minutes since start (binned)',
      },
      y: {
        title: 'executions',
        aggregate: 'count',
      },
      column: {
        field: 'scenario',
        header: { title: null },
      }
    },
    data: { values: eventLog }
  })

  vegaEmbed('#vis-execution-failures-per-minute', {
    $schema: 'https://vega.github.io/schema/vega-lite/v4.json',
    title: 'execution failures per minute',
    width: chartWidth,
    mark: { 
      type: 'bar', 
      tooltip: true, 
      cornerRadiusEnd: 4,
      color: colors[2],
    },
    encoding: {
      x: {
        bin: { step: 1 },
        field: 'minute',
        type: 'ordinal',
        title: 'minutes since start (binned)',
      },
      y: {
        title: 'executions',
        aggregate: 'count',
      },
      column: {
        field: 'deployment',
        header: { title: null },
      }
    },
    data: { values: eventLog.filter(log => log.outcome === 'failure') }
  })

  vegaEmbed('#vis-kb-status', {
    $schema: 'https://vega.github.io/schema/vega-lite/v4.json',
    title: 'kibana metrics',
    data: { values: kbStatus },
    hconcat: [
      metricSpec('load avg (1m)', 'metrics.os.load.1m'),
      metricSpec('event loop delay', 'metrics.process.event_loop_delay'),
      metricSpec('rss', 'metrics.process.memory.resident_set_size_in_bytes'),
    ]
  })

  const flattenedTMStats = Object.entries(KbTaskManager)
    .reduce((scenarios, [scenario, stats]) => {
      // flaten all TM stats under their scenario
      scenarios[scenario] = Object.values(stats).reduce((all, tm) => [...all, ...tm], [])
      return scenarios
    },{})

  vegaEmbed('#vis-kb-tm-stats', {
    $schema: 'https://vega.github.io/schema/vega-lite/v4.json',
    title: 'kibana Task Manager metrics',
    datasets: flattenedTMStats,
    hconcat: [
      ...Object.keys(flattenedTMStats)
        .map(scenario => tmMetricSpec(`Drift (p50) ${scenario}`, 'stats.runtime.value.drift.p50', scenario)),
      ...Object.keys(flattenedTMStats)
        .map(scenario => tmMetricSpec(`Drift (p90) ${scenario}`, 'stats.runtime.value.drift.p90', scenario)),
      ...Object.keys(flattenedTMStats)
        .map(scenario => tmMetricSpec(`Alert Task Duration (p50) ${scenario}`, 'stats.runtime.value.duration.p50', scenario)),
      ...Object.keys(flattenedTMStats)
        .map(scenario => tmMetricSpec(`Alert Task Duration (p90) ${scenario}`, 'stats.runtime.value.duration.p90', scenario))
    ]
  })
   
  const normaliseRuntimeResults = Object.entries(flattenedTMStats)
    .reduce((scenarios, [scenario, stats]) => {
      scenarios[scenario] = stats.reduce((allRuntimeStats, tmStats) => {
        const { id, dateRelative } = tmStats
        const { result = {}, polling : { results: polling } = {} } = tmStats.stats.runtime.value
        Object.entries({ result, polling })
          .forEach(([stat, metrics]) => {
            if(Math.max(...Object.values(metrics)) > 0){
              Object
                .entries(metrics)
                .forEach(([category, percentage]) => {
                  allRuntimeStats.push({ id, dateRelative, stat, category, percentage })
                })
            }
          })

        return allRuntimeStats
      }, [])
      return scenarios
    },{})

  console.log(normaliseRuntimeResults)

  vegaEmbed('#vis-kb-tm-runtime-stats', {
    $schema: 'https://vega.github.io/schema/vega-lite/v4.json',
    title: 'kibana Task Manager Runtime Results',
    datasets: normaliseRuntimeResults,
    hconcat: [
      ...Object.keys(normaliseRuntimeResults)
        .map(scenario => tmPieMetricSpec(`Task Run Results ${scenario}`, 'result', scenario)),
      ...Object.keys(normaliseRuntimeResults)
        .map(scenario => tmPieMetricSpec(`Task Polling Results ${scenario}`, 'polling', scenario))
    ]
  })

  vegaEmbed('#vis-kb-tm-polling-results-stats', {
    $schema: 'https://vega.github.io/schema/vega-lite/v4.json',
    title: 'kibana Task Manager Polling Results',
    datasets: normaliseRuntimeResults,
    vconcat: Object.keys(flattenedTMStats)
      .map(scenario => 
        Object.keys(KbTaskManager[scenario])
          .map(tm => ({
            title: `"${tm}" Polling Result throughout ${scenario}`,
            data: { name: scenario },
            width: chartWidth * 4,
            transform: [
              {
                filter: { field: "stat", equal: "polling" }
              },
              { filter: { field: "id", equal: tm } }
            ],    
            mark: "area",
            encoding: {
              x: {
                "title": "minutes since start",
                "field": "dateRelative",
                "type": "temporal",
                "axis": {
                  "format": "%-M",
                  "formatType": "time",
                  "tickCount": "minute"
                }
              },
              y: {
                "aggregate": "sum", "field": "percentage",
                "axis": null,
                "stack": "normalize"

              },
              color: { field: "category" }
            }
          })
        )
      )
      .reduce((all, tm) => [...all, ...tm], [])
  })
   
  const calculatedPollingTimeline = Object.entries(KbTaskManager)
    .reduce((scenarios, [scenario, stats]) => {
      const earliestSuccessfulPollInScenario = Math.min(
        ...Object.values(stats)
          .map(stats => Date.parse(stats[0].stats.runtime.value.polling.lastSuccessfulPoll))
      )

      scenarios[scenario] = Object.values(stats)
        // for each TM mark the successful polls and estimate the ones inbetween measurments
        .map((tm) => {
          const pollInterval = tm[0].stats.configuration.value.poll_interval
          let previousLastPollingDelay = 0
          return tm.reduce((allRuntimeStats, tmStats) => {
            const { id } = tmStats
            const { polling: { lastSuccessfulPoll, lastPollingDelay, duration, claimConflicts } = {} } = tmStats.stats.runtime.value
            if(lastSuccessfulPoll && duration){
              const pollTimestamp = Date.parse(lastSuccessfulPoll) - earliestSuccessfulPollInScenario
              const lastPoll = allRuntimeStats[allRuntimeStats.length - 1]
              if(lastPoll) {
                // estimate all polling poing between this poll and the previous measured one
                for(
                  let estimatedPoll = lastPoll.pollTimestamp + pollInterval;
                  estimatedPoll < pollTimestamp;
                  estimatedPoll = estimatedPoll + pollInterval
                ) {
                  allRuntimeStats.push({
                    id,
                    pollTimestamp: estimatedPoll,
                    duration: {
                      p99: estimatedPoll - duration.p99,
                      p95: estimatedPoll - duration.p95,
                      p50: estimatedPoll - duration.p50,
                    },
                    type: 'estimated'
                  })
                  allRuntimeStats.push({ id: 'all', pollTimestamp: estimatedPoll, type: 'estimated' })
                }
              }

              const pollDelayTimestamp = Date.parse(lastPollingDelay) - earliestSuccessfulPollInScenario
              const pollDelayChanged = pollDelayTimestamp > 0 &&
                previousLastPollingDelay !== lastPollingDelay

              if(pollDelayChanged) {
                previousLastPollingDelay = lastPollingDelay
              }

              allRuntimeStats.push({
                id,
                pollTimestamp,
                pollDelayChanged,
                duration: {
                  p99: pollTimestamp - duration.p99,
                  p95: pollTimestamp - duration.p95,
                  p50: pollTimestamp - duration.p50,
                },
                claimConflicts,
                type: 'measured'
              })
              allRuntimeStats.push({ id: 'all', pollTimestamp, type: 'measured' })
            }
            return allRuntimeStats
          }, [])
        })
        // flatten all TM stats under their scenario
        .reduce((all, tm) => [...all, ...tm], [])
      return scenarios
    },{})

  console.log(calculatedPollingTimeline)

  vegaEmbed('#vis-kb-tm-polling-stats', {
    $schema: 'https://vega.github.io/schema/vega-lite/v4.json',
    title: 'kibana Task Manager Polling  Timeline',
    datasets: calculatedPollingTimeline,
    vconcat: Object.entries(calculatedPollingTimeline)
        .reduce((allCharts, [scenario, scenarioStats]) => {
          // show wholew timeline
          allCharts.push(
            tmMetricPollingTimeline(
              `Zoom Into Timeline of ${scenario}`,
              scenario,
              chartWidth * 4,
              { "brush": { "type": "interval", "encodings": ["x"]} }
            )
          )
          allCharts.push(
            tmMetricPollingTimeline(
              `Whole Timeline of ${scenario}`,
              scenario,
              chartWidth * 4,
              "brush",
              // sort by IDs so that `all` is last
              Object.keys(KbTaskManager[scenario])
            )
          )
          allCharts.push({
            "$schema": "https://vega.github.io/schema/vega-lite/v4.json",
            title: `Sampled Polling Overlap of ${scenario}`,
            data: { "name": scenario },
            width: chartWidth * 4,
            "encoding": {
                "y": {
                  "field": "id",
                  "type": "nominal",
                  "title": null
                }
            },
            transform: [
              // { filter: { field: "pollTimestamp", range: twoPollingCyclesInTheMiddle } },
              { filter: { field: "id", oneOf: Object.keys(KbTaskManager[scenario]) } }
            ],
            "layer": [
              {
                "mark": {"type": "rule"},
                "encoding": {
                  "x": {
                    "field": "duration.p99",
                    type: 'temporal',
                    axis: {
                      format: '%M:%S',
                      formatType: 'time',
                      minExtent: 100
                    },
                    scale: { domain: { selection: "brush" }},
                    "title": null
                  },
                  "x2": {
                    "field": "pollTimestamp",
                    type: 'temporal',
                    axis: {
                      format: '%M:%S',
                      formatType: 'time',
                      minExtent: 100
                    },
                    scale: { domain: { selection: "brush" }}
                  }
                }
              },
              {
                "mark": {"type": "bar", "size": 14},
                "encoding": {
                  "x": {
                    "field": "duration.p95",
                    type: 'temporal',
                    axis: {
                      format: '%M:%S',
                      formatType: 'time',
                      minExtent: 100
                    },
                    scale: { domain: { selection: "brush" }}
                  },
                  "x2": {
                    "field": "pollTimestamp",
                    type: 'temporal',
                    axis: {
                      format: '%M:%S',
                      formatType: 'time',
                      minExtent: 100
                    },
                    scale: { domain: { selection: "brush" }}
                  },
                  "color": {"field": "id", "type": "nominal", "legend": null}
                }
              }
            ]
          })
          allCharts.push({
            "$schema": "https://vega.github.io/schema/vega-lite/v4.json",
            title: `Claim Conflicts p50 of ${scenario}`,
            data: { "name": scenario },
            width: chartWidth * 4,
            layer: [
            {
                transform: [
                  { filter: { field: "type", equal: 'measured' } },
                  { filter: { field: "id", oneOf: Object.keys(KbTaskManager[scenario]) } }
                ],
                mark: {
                  "type": "circle",
                  "opacity": 0.8,
                  "stroke": "black",
                  "strokeWidth": 1
                },
                encoding: {
                  x: {
                    field: "pollTimestamp",
                    type: 'temporal',
                    axis: {
                      format: '%M:%S',
                      formatType: 'time',
                      minExtent: 100
                    }
                  },
                  y: {
                    "field": "id",
                    "type": "nominal",
                    "axis": {
                      title: ""
                    }
                  },
                  size: {
                    "field": "claimConflicts.p50",
                    "type": "quantitative",
                    "title": "Claim Conflicts p50",
                    "legend": { clipHeight: 30 },                
                    "scale": {
                      "domainMin": 0,
                      "domainMax": 10,
                      "rangeMin": 0,
                      "rangeMax": 5000
                    }
                  },
                  color: {
                    "field": "id",
                    "type": "nominal",
                    "legend": null
                  }
                }
              }, {
                transform: [
                  { filter: { field: "pollDelayChanged", equal: true } },
                  { filter: { field: "id", oneOf: Object.keys(KbTaskManager[scenario]) } }
                ],
                mark: {
                  type: "point",
                  shape: "wedge",
                  angle: 90,
                  filled: false,
                  stroke: "#fff",
                  size: 1000
                },
                encoding: {
                  x: {
                    field: "pollTimestamp",
                    type: 'temporal',
                    axis: {
                      format: '%M:%S',
                      formatType: 'time',
                      minExtent: 100
                    }
                  },
                  y: {
                    "field": "id",
                    "type": "nominal",
                    "axis": {
                      title: ""
                    }
                  }
                }
              }              
            ]            
          })
          return allCharts
        }, [])
  })

  // reduce to one TM for schedule density 
  const flattenedTMScheduleDensity = Object.entries(KbTaskManager)
    .reduce((scenarios, [scenario, stats]) => {
      // choose one TM and reduce to its schedule density stat
      const allTaskManagers = Object.values(stats);
      const randomTaskManager = allTaskManagers[0];
      const earliestTMScheduleDensityInScenario = Date.parse(randomTaskManager[0].stats.workload.timestamp)

      const measuredTimestamps = new Set()

      scenarios[scenario] = randomTaskManager.reduce((allDensities, stat, statCycle) => {
        //skip duplicate measurments
        if(measuredTimestamps.has(stat.stats.workload.timestamp)){
          return allDensities
        }
        measuredTimestamps.add(stat.stats.workload.timestamp)

        const pollInterval = stat.stats.configuration.value.poll_interval
        const taskManagmentStatsTakenAt = Date.parse(stat.stats.workload.timestamp)
        // rounmd measuredAt relative to the previous TM measurments so that they all fall in the same bucket
        const measuredAt = taskManagmentStatsTakenAt -
          ((taskManagmentStatsTakenAt - earliestTMScheduleDensityInScenario) % pollInterval)

        allDensities.push(
          ...stat.stats.workload.value.estimated_schedule_density
            .map((scheduled, cycle) => ({
              scheduled,
              availableWorkers: stat.stats.configuration.value.max_workers * allTaskManagers.length,
              scheduledAt: measuredAt + cycle * pollInterval,
              measuredAt
            }))
        )
        return allDensities
      }, [])
      return scenarios
    }, {})

  console.log(flattenedTMScheduleDensity)

  vegaEmbed('#vis-kb-tm-schedule', {
    $schema: 'https://vega.github.io/schema/vega-lite/v4.json',
    title: 'kibana Task Manager Schedule Density',
    datasets: flattenedTMScheduleDensity,
    width: "container",
    hconcat: Object.entries(flattenedTMScheduleDensity)
      .map(([scenario, tmScheduleDensity]) => ({
      title: `Schedule Density ${scenario}`,
      data: { name: scenario },
      mark: "rect",
      encoding: {
        x: {
          field: "scheduledAt",
          title: "Scheduled At",
          // "timeUnit": {
          //   "unit": "milliseconds",
          //   "step": 3000
          // }
        },
        y: {
          field: "measuredAt",
          title: "Measured At"
        },
        color: {
          field: "scheduled",
          condition: {
            "test": `datum['scheduled'] > datum['availableWorkers']`,
            "value": "red"
          },
          type: "quantitative",
        }
      }
    }))
  })

  vegaEmbed('#vis-es-status', {
    $schema: 'https://vega.github.io/schema/vega-lite/v4.json',
    title: 'elasticsearch metrics',
    data: { values: esStatus },
    hconcat: [
      metricSpec('heap %', 'heapPercent'),
      metricSpec('ram %', 'ramPercent'),
      metricSpec('cpu', 'cpuPercent'),
    ]
  })

  function metricSpec(title, field) {
    return {
      title,
      width: chartWidth,
      mark: { 
        type: 'line', 
        opacity: 0.6,
        tooltip: true
      },
      encoding: {
        x: {
          title: 'minutes since start',
          field: 'dateRelative',
          type: 'temporal',
          axis: {
            format: '%-M',
            formatType: 'time',
            tickCount: 'minute',
          }
        },
        y: {
          title: null,
          field,
          type: 'quantitative',
          scale: { zero: true },
          axis: { grid: false }
        },
        color: {
          field: 'scenario',
          scheme: 'set1',
        },
      },
    }
  }

  
  function timestampAsTime(timestamp){
    return `${new Date(timestamp).getMinutes()}:${new Date(timestamp).getSeconds()}`
  }

  function tmMetricPollingTimeline(title, data, width, selection, tmIDs) {
    return {
      title,
      data: { "name": data },
      mark: "tick",
      width,
      ...(
        typeof selection === 'object'
        ? {
            selection,
            transform: [
              { filter: { field: "id", equal: 'all' } },
              { filter: { field: "type", equal: 'measured' } }
            ] 
          }
        : {}
      ),
      encoding: {
        x: {
          field: "pollTimestamp",
          type: 'temporal',
          ...(
            typeof selection === 'string'
            ? { scale: { domain: { selection }}, }
            : {}
          ),
          axis: {
            format: '%M:%S',
            formatType: 'time',
          }
        },
        y: {
          field: "id",
          type: "ordinal",
          ...(
            tmIDs
            // sort by IDs so that 'all' in in the middle
            ? { sort: tmIDs }
            : {}
          ),
          
        },
        color: {
          field: "type",
          type: "nominal",
          legend: {
            values: ["estimated", "measured"]
          }
        }
      }
    }
  }
  
  function tmMetricSpec(title, field, data) {
    return {
      title,
      data: { name: data },
      width: chartWidth,
      mark: { 
        type: 'line', 
        opacity: 0.6,
        tooltip: true
      },
      "selection": {
        "taskManagerID": {
          "type": "multi", "fields": ["id"], "bind": "legend"
        }
      },
      encoding: {
        x: {
          "title": "minutes since start",
          "field": "dateRelative",
          "type": "temporal",
          "axis": {
            "format": "%-M",
            "formatType": "time",
            "tickCount": "minute"
          }
        },
        y: {
          field,
          "type": "quantitative"
        },
        color: {
          "field": "id",
          "type": "nominal"
        },
        "opacity": {
          "condition": {
            "selection": "taskManagerID",
            "value": 1
          },
          "value": 0.2
        }
      }
    }
  }

  function tmPieMetricSpec(title, field, data) {
    return {
      title,
      data: { name: data },
      width: chartWidth,
      mark: "bar",
      transform: [
        {
          filter: { "field": "stat", "equal": field }
        },
        {
          "groupby": [`id`],
          "joinaggregate": [
            {
              "op": "sum",
              "field": `percentage`,
              "as": "totalResults"
            }
          ]
        },
        {
          "calculate": `datum.percentage/datum.totalResults * 100`,
          "as": "percentOfTotal"
        }
      ],
      "selection": {
        "result": {
          "type": "multi", "fields": ["category"], "bind": "legend"
        }
      },
      encoding: {
        x: {
          field: `percentOfTotal`,
          type: "quantitative",
          title: "% of all Results"
        },
        y: {
          "field": `id`
        },
        color: {
          "field": `category`
        },
        "opacity": {
          "condition": {
            "selection": "result",
            "value": 1
          },
          "value": 0.2
        }
      },
      resolve: {
        scale: {
          color: "independent"
        },
        legend: {
          color: "independent"
        }
      }
    }
  }

  function getSharedSettings() {
    const { sameVals } = getScenarioSameAndDiffProps()

    const result = []
    for (const key of Array.from(sameVals.keys()).sort()) {
      result.push(`<tr><td>${key}:</td><td align="right">${sameVals.get(key)}</td></tr`)
    }

    return result.join('\n')
  }

  function getScenarioSetttings() {
    const { sameVals, diffVals } = getScenarioSameAndDiffProps()

    const result = []
    for (const deployment of deployments) {
      result.push(`<h4>${deployment.scenario.sortName}</h4>`)
      result.push('<div class="indent">')
      result.push(`<table>`)
      for (const key of Array.from(diffVals.keys()).sort()) {
        result.push(`<tr><td>${key}:</td><td align="right">${deployment.scenario[key]}</td></tr>`)
      }
      result.push('</table>')
      result.push('</div>')
    }

    return result.join('\n')
  }

  function getScenarioPropsAndNames() {
    /** @type { Set<string> } */
    const allProps = new Set()
    /** @type { string[] } */
    const names = []
    for (const deployment of deployments) {
      const scenario = deployment.scenario
      for (const key of Object.keys(scenario)) {
        if (key === 'name') {
          names.push(scenario.name)
        } else if (key !== 'sortName') {
          allProps.add(key)
        }
      }
    }

    return {
      names,
      props: Array.from(allProps.values()).sort()
    }
  }

  function getScenarioSameAndDiffProps() {
    const { props } = getScenarioPropsAndNames()

    /** @type { Map<string, any> } */
    const sameVals = new Map()
    /** @type { Set<string> } */
    const diffVals = new Set()

    for (const deployment of deployments) {
      const scenario = deployment.scenario
      for (const prop of props) {
        if (!sameVals.has(prop)) {
          sameVals.set(prop, scenario[prop])
        } else {
          if (sameVals.get(prop) !== scenario[prop]) {
            diffVals.add(prop)
          }
        }
      }
    }

    for (const diffValKey of diffVals) {
      sameVals.delete(diffValKey)
    }

    return {
      sameVals,
      diffVals,
    }
  }

  function getAllData() {
    const data = 
    // data-start
    {
      /** @type { any } */
      suite: "%Suite%",
      /** @type { any[] } */
      deployments: ["%Deployments%"],
      /** @type { any[] } */
      eventLog: ["%EventLog%"],
      /** @type { any[] } */
      kbStatus: ["%KbStatus%"],
      /** @type { Record<string, any[]> } */
      KbTaskManager: ["%KbTaskManager%"],
      /** @type { any[] } */
      esStatus: ["%EsStatus%"],
    }
    // data-end

    return data
  }
</script>

</html>
